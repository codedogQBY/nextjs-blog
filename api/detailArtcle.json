{
  "code": 1,
  "message": "文章获取成功",
  "result": {
    "_id": "6097d01735a6fc0c0c297502",
    "id": 95,
    "title": "生产环境落地 ESModule",
    "keyword": "ESModule",
    "descript": "自从 `ESModule` 成为标准实现以来，开发者们不断讨论在生产环境落地的可能性。",
    "content": "自从 `ESModule` 成为标准实现以来，开发者们不断讨论在生产环境落地的可能性。\n\n## ESModule 带来的变化\n\n直至当下，大部分开发者们仍习惯以 `webpack` 之类的 bund 工具来搭建开发环境，在几年以前这并没有什么不好，但随着项目越来越大，`webpack` 的一些缺点受到越来越多的吐槽，其中最大的槽点莫过于在开发环境 `webpack` 会将所有的代码打包成一个非常大的 bund，当项目达到数十万行时，这将是是一个非常耗时的过程，`hot reload` 也将变的非常缓慢。而在生产环境时，`webpack` 构建后的代码会远大于编写的代码，这些额外的代码有一部分是对用户来说无用的依赖管理代码，一些是为了兼容用户量不足10%的低版本浏览器 `polyfill`。\n\n自高版本浏览器支持 `ESModule` 以来，一些 `nobund` 构建工具如 `Snowpack` 、`Vite` 便利用该特性，直接跑 `ESModule`，而无需像 Webpack 一样打包成一个 bund。\n\n![https://www.snowpack.dev/img/snowpack-unbundled-example-3.png](https://www.snowpack.dev/img/snowpack-unbundled-example-3.png)\n\nSnowpack vs Webpack\n\n```jsx\nexport const str = 'hello world';\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n    </head>\n    <body>\n        <script type=\"module\">\n            import { str } from './main.js';\n            console.log(str); // hello world\n        </script>\n    </body>\n</html>\n```\n\n以上就是一个最简单的实例代码。\n\n当落地到开发环境时，`nobund` 工具先会将所有的用到的 `npm` 包转换为 `ESModule`（Snowpack 3 版本支持「`[stream import](https://www.snowpack.dev/posts/2021-01-13-snowpack-3-0)`」不会预先构建 `npm` 包），并放入特定文件夹中。它们启动的 `dev server` 会对代码按需编译，通常情况下，首次启动的时间在 50ms 以内，hot reload 也能控制在极短的时间。\n\n在生产环境时，一些开发者认为由于「嵌套导入」的影响，将会比较大的影响性能，倾向于打包成一个 bundle。但是该种方式却不利于缓存（修改一行代码，也将会导致缓存失效），另外一些开发者更倾向于部署 `ESModule`，对于 npm 中使用的包，也只是做一些 `tree shaking` 和转化成 `ESModule` 之类的简单处理，这能带来尽可能多的包被缓存，但是这也意味着你的代码需要更长时间被加载完成。\n\n## 面对的问题\n\n### 缓存与加载效率\n\n正如上文所提及的，如何在缓存与加载效率之间取的平衡是一个令人头疼的问题，把第三方插件经过 `tree shaking` 后打包成一个公共的包，所编写的代码由 `import()` 拆分，似乎是一个不错的注意（`Vite` 所使用的方式），但是对于一个处于迭代中的项目来说，增加插件或者是升级插件会是一件比较频繁的事情。一些开发者则倾向于更细粒度地打包，通过 `rollup` 提供的 `manualChunks` 功能，把相关模块的包打包到一个 `chunk` 中：\n\n```jsx\nmanualChunks(id) {\n      if (id.includes('node_modules')) {\n        // The directory name following the last `node_modules`.\n        // Usually this is the package, but it could also be the scope.\n        const directories = id.split(path.sep);\n        const name = directories[directories.lastIndexOf('node_modules') + 1];\n\n        // Group react dependencies into a common \"react\" chunk.\n        // NOTE: This isn't strictly necessary for this app, but it's included\n        // as an example to show how to manually group common dependencies.\n        if (name.match(/^react/) || ['prop-types', 'scheduler'].includes(name)) {\n          return 'react';\n      }\n\n      // Group `tslib` and `dynamic-import-polyfill` into the default bundle.\n      // NOTE: This isn't strictly necessary for this app, but it's included\n      // to show how to manually keep deps in the default chunk.\n      if (name === 'tslib' || name === 'dynamic-import-polyfill') {\n        return;\n      }\n\n      // Otherwise just return the name.\n      return name;\n    }\n}\n```\n\n使用该方式拆分包后，大部分的包都能被很好的缓存，但是加载的时间会稍长。\n\n除此之外，社区出现了 `http-import` 即不打包的形式。所使用的包，都从 CDN 上拉取，缓存、转 ESM、依赖地狱的优化等都由 CDN 来处理。\n\n```jsx\n<script type=\"module\">\n  import lodash from 'https://cdn.skypack.dev/lodash';\n</script>\n```\n\n当配合 `import-maps` 使用时，\n\n```jsx\n<script type=\"importmap\">\n        // 可由构建工具打包出一份 maps\n        {\n            \"imports\": {\n                \"lodash/\": \"https://cdn.skypack.dev/lodash/\"\n            }\n        }\n</script>\n<script type=\"module\">\n        // 构建后的代码\n        import array from 'lodash/array';\n        // do things\n</script>\n```\n\n不过该 [proposal](https://github.com/WICG/import-maps) 正式使用时不知道是猴年马月了。\n\n`Snowpack` 3.0 中 `Streaming Imports` 实际上也是用了这种形式：\n\n```jsx\n// you do this:\nimport * as React from 'react';\n\n// but get behavior like this:\nimport * as React from 'https://cdn.skypack.dev/react@17.0.1';\n```\n\n本地无须装包，当识别到 `import` 第三方包时，可以直接从 CDN 上拉取。\n\n### npm 包的规范性\n\n由于一些历史原因，打包发布的 npm 包通常只含有 `CommonJS` 模块，并会在 `package.json` 中指定该模块的入口：\n\n```json\n{\n\t\"main\": \"./index.js\"\n}\n```\n\n但是 `ESModule` 却不能加载 `CommonJS` ，需要通过一些必要的插件处理，如 `Rollup` `@rollup/plugin-commonjs` 插件，会将 `CommonJS` 模块转化为 `ESModule` 模块。\n\n对于一些 `ESModule` 的 npm 包，可以在 `package.json` 中使用 `module` 字段来标明该包的输出格式是 `ESModule`:\n\n```json\n{\n    \"module\": \"./index.ems.js\",\n}\n```\n\n当使用 `rollup` `webpack` 这类构建工具时，如果识别到有该字段，则会优先加载指定的 `ESModule` 模块，这也有利于它们进行 `tree-sharking` 之类的优化。\n\n当 npm 包同时有 `CommonJS` 模块、`ESModule` 模块时，那么推荐的做法是：\n\n```json\n// recommended: web + node.js package.json\n{\n  \"main\": \"./index.cjs.js\",\n  \"module\": \"./index.esm.js\"\n}\n```\n\n此外，可以添加 `package.json` `exports` 字段，用作 `Conditional exports`：\n\n```json\n{\n  \"main\": \"./index.cjs.js\",\n  \"module\": \"./index.esm.js\",\n  \"exports\": {\n    \"require\": \"./index.cjs.js\",\n    \"import\": \"./index.esm.js\"\n  }\n}\n```\n\n### 其他\n\n- 对于不兼容 ESModule 的浏览器而言，有一个 fallback 的方案\n\n```jsx\n<script type=\"module\" src=\"module.mjs\"></script>\n<script nomodule src=\"fallback.js\"></script>\n```\n\n- 高效预加载 `ESModule`\n\n```jsx\n<!-- 可由构建工具生成 -->\n<link rel=\"modulepreload\" href=\"/modules/main.XXXX.mjs\">\n<link rel=\"modulepreload\" href=\"/modules/npm.pkg-one.XXXX.mjs\">\n<link rel=\"modulepreload\" href=\"/modules/npm.pkg-two.XXXX.mjs\">\n<link rel=\"modulepreload\" href=\"/modules/npm.pkg-three.XXXX.mjs\">\n<!-- ... -->\n<script type=\"module\" src=\"/modules/main.XXXX.mjs\"></script>\n```\n\n随着 No bound 构建工具的出现，`ESModule` 在生产环境的落地越来越简单。适用于 ESM 下一代 CDN 的发展，也让 `ESModule` 的落地有了更多的想象空间。相信在不久的未来，`ESModule` 将会成为主流，在开发体验及网站速度上，都会有较大幅度的提升。\n\n### 参考\n\n- [package.json 中 browser，module，main 字段](https://github.com/SunshowerC/blog/issues/8#webpack-web-esm)\n- [package.json exports](https://nodejs.org/api/packages.html#packages_exports)\n- [ESModule in browsers](https://jakearchibald.com/2017/es-modules-in-browsers/)\n- [import-maps](https://github.com/WICG/import-maps)",
    "type": 1,
    "thumb": "",
    "__v": 0,
    "meta": { "comments": 0, "likes": 6, "views": 83 },
    "update_at": "2021-05-09T14:39:01.596Z",
    "create_at": "2021-05-09T12:05:43.767Z",
    "publish": 1,
    "state": 1,
    "tag": [
      {
        "_id": "59d6dfb8c72f12628eea9428",
        "id": 9,
        "name": "JavaScript",
        "descript": "JavaScript 的基础及其深入",
        "__v": 0,
        "update_at": "2018-07-08T01:30:34.391Z",
        "sort": 16,
        "create_at": "2017-10-06T01:43:20.699Z"
      }
    ]
  }
}
